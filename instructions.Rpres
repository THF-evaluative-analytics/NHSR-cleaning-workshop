```{r setup, include=FALSE}
knitr::opts_chunk$set(eval = FALSE)
```



Introduction to data wrangling
========================================================
author: Emma Vestesson 
date: 
autosize: true
font-family: 'Georgia'



What we will cover today
===========================================

- Dplyr main verbs
- Reshaping data
- Joining two data sets

Getting up to speed
==============================
Workshop is aimed at advanced beginners and I will assume some familiarity with R and the tidyverse. We will spend a few minutes to refamiliarise ourselves with R.

You will need to have `tidyverse` package installed and loaded.  

Packages in R
=====================

The first time you use it you need to install the package. 

```{r, eval=FALSE}
install.packages("tidyverse")
```

Load the package
```{r}
library(tidyverse)
```

The pipe
========================================

Simplifying R code with pipes (%>%)
- Easy way to pass data through functions without nesting
- First argument of each function is “piped” in to reduce redundancy
- f(x) is the same as x %>% f()
- f(x, y) is the same as x %>% f(y)
- Keyboard shortcut ctrl+shift +m

The pipe
==============================

```{r}
leave_house(get_dressed(get_out_of_bed(wake_up(me))))

```
VS
```{r}
me %>% 
  wake_up() %>% 
  get_out_of_bed() %>% 
  get_dressed() %>% 
  leave_house()
```


Rstudio tips
========================================================
- ctrl + shift + m will create a pipe ( %>% )
- start a new R session (keyboard short ctrl+shift+F10)
- the :: operator is your friend eg dplyr::select()

Main dplyr verbs 
========================================================
Grammar of data manipulation:
+ select() picks variables (columns) based on their names
+ filter() allows row selection based on given criteria
+ mutate() creates new variables (columns) from existing ones
+ summarise() reduces multiple values down to a single summary

Main dplyr helper verbs
=======================================
+ group_by() performs any of the above on a group-by-group basis
+ arrange() changes the ordering of rows

```{r, include=FALSE}
library(tidyverse)
library(tidylog)
library(lubridate)
```

Helper functions with select()
================================

Helper functions you can use within select():
+ starts_with(“e_”) matches names that begin with “e_”
+ ends_with(“_end”) matches names that ends with “_end”
+ contains(“_h12”) matches names that contain “_h12”
+ matches(<regex>) allows you to do regex matching on names eg matches("abc|abd") 


Example select()
===============================
```{r}
# Select variables/columns 2 to 5 and save data as new_dat
new_dat <- select(starwars, 2:5)

# Drop variables height and mass (same as keeping all variables but height and mass)
starwars %>% 
  select( -height, -mass) 

starwars %>% 
  select(name, ends_with("color"))
```

Example filter
============================================

```{r}

starwars %>% 
  filter(mass>80,  hair_color=="white")

starwars %>% 
  filter(is.na(hair_color))
```


Example mutate
===============================

```{r}
starwars %>% 
  mutate(height_m=height/100, bmi=mass/(height_m^2), bmi=round(bmi, 1)) 
```


Example summarise
===================================

```{r}
starwars %>%
  summarise(height_mean = mean(height, na.rm=TRUE))

starwars %>%
  group_by(homeworld) %>% 
  summarise(height_max = max(height, na.rm=TRUE))

```


Exercise 1
==========================================
See exercise script but also use your post-its

pink sticker = I need help

green = DONE!


Try it!
===========================================

+ Find the rows where height > 100
+ Find the rows where height > 90 and hair_color is not brown
+ Find the rows where eye_color is  brown
+ Find the rows where hair_color is missing
+ Find the rows where hair_color is NOT missing
+ Find the rows where hair_color is white
+ Find the rows where hair_color contains the word white

How are you done already? 
============================================
+ Select the first 3 columns of starwars
+ Select name and mass
+ Select columns with string `color` in them
+ Select all columns BUT height and mass
+ Create a new variable called `half_mass` that is half of mass
+ Create variable `height_cat` with 3 categories "short", "medium", "tall" if `height` [0,70], ]70,90], ]90,inf[   
+ Create variable `small` that is 1 if mass is less than the mean of `mass` and 0 otherwise. 


Solution
============================================

```{r}
starwars %>% 
  filter(height>100)

starwars %>% 
  filter(height>90, hair_color!="brown")

starwars %>% 
  filter(eye_color=="brown")

starwars %>% 
  filter(is.na(hair_color))

starwars %>% 
  filter(!is.na(hair_color))

starwars %>% 
  filter(str_detect(hair_color, "white"))

starwars %>% 
  select(1:3) 
starwars %>% 
  select(name,mass)
starwars %>% 
  select(contains("color"))
starwars %>% 
  select( -c(height, mass) )

starwars %>% 
  mutate(half_mass=mass/2)
starwars %>% 
  mutate(height_cat=case_when(height<=70 ~ "short",
                              height>70 & height<=90 ~ "medium",
                              height>90 ~ "tall"))
starwars %>% 
  mutate(small=if_else(mass<=mean(mass, na.rm = TRUE), 1,0))

```


Scoped verbs
==========================================
+ Terminology: we have been using “single table verbs”
+ Now we can affect multiple variables simultaneously with the scoped verbs 
+ Three extensions
  - _if pick variables based on a predicate function like is.numeric() or a user defined function function(x) do_this(x) 
  + _at pick variables using the same syntax as select().
  + _all operates on all variables

mutate_if
==========================================

```{r}
starwars %>% 
  mutate_if(is.numeric, ~round(.) )

```

select_at 
================= 
 
```{r, echo=FALSE}
colour_vars <- c("hair_color", "skin_color", "eye_color")

starwars %>% 
  select_at(colour_vars)

starwars %>% 
  select_at(vars(-colour_vars))

numeric_vars <- starwars %>%  
  select_if(is.numeric) %>% 
  names()
```
 
 summarise_all
================================== 
 
```{r, echo=FALSE}
starwars %>% 
  summarise_at(numeric_vars, ~mean(.x, na.rm=TRUE))

starwars %>% 
  group_by(hair_color) %>% 
  summarise_if(is.numeric, list(min=min, max=max))
```
 
 
Exercises
==========================================
- What variables are characters? 
- Remove all numeric observations with missing values
- Calculate the mean of all numeric variable by homeworld.

Solution
==========================================
  
```{r, echo=FALSE}
starwars %>% 
  select_if(is.character) %>% 
  names()
starwars %>% 
  filter_if(is.numeric, ~!is.na(.x))

starwars %>% 
  group_by(homeworld) %>% 
  summarise_if(is.numeric, ~mean(.x, na.rm=TRUE))

```
  
  
Tidy data
==========================================
Data comes in all kinds of shapes and forms. 

1. Each variable forms a column.
2. Each observation forms a row.
3. Each type of observational unit forms a table.

Sitrep data
==========================================

Downloaded data from [NHSE website](https://www.england.nhs.uk/statistics/statistical-work-areas/winter-daily-sitreps/winter-daily-sitrep-2017-18-data/) and saved in R data format. 


```{r}
sitrep <- readRDS(here::here('data', 'sitrep.RDS')) # all calls
sitrep_60sec <- readRDS(here::here('data', 'sitrep_60sec.RDS')) # calls answered within 60sec
```
Look at data. Is is tidy? 


New tidyr package
==========================================
The `tidyr` package was updated early September. `Spread` and  `gather` have been replaced by `pivot_longer` and `pivot_wider`. 


 
==========================================
```{r}
sitrep_long <- sitrep %>% 
  pivot_longer(-c(NHS_111_area_name, year), names_to='day_month', values_to='calls')
```
Our data is long! But we can make it even tidier. Suggestions? 


Sorting out the date
============================================

```{r}
sitrep_long <- sitrep_long %>% 
  mutate(day_month=str_replace(day_month, '_', '-'), date=paste(year, day_month, sep='-'), date=ydm(date)) 
```

Time for you to try
===============================

Reshape the `sitrep_60sec` data frame and create a date variable. Call your new data frame `sitrep_60sec_long`.


==========================================
```{r}
sitrep_60sec_long <- sitrep_60sec %>% 
  pivot_longer(-c(NHS_111_area_name, year), names_to='day_month', values_to='calls') %>% 
    mutate(day_month=str_replace(day_month, '_', '-'), date=paste(year, day_month, sep='-'), date=ydm(date)) 
  
```


Join the two data set
==========================================
Joining data in R is very similar to sql. 
- full_join()
- left_join()
- right_join()
- inner_join()
- anti_join()
- semi_join()

Join our two data sets
=========================================

```{r}
sitrep_full <- full_join(sitrep_long, sitrep_60sec_long, by=c('NHS_111_area_name', 'date'), suffix=c('_all','_60sec'))
```

Play with the data set 
=========================================

- Drop all the extra variables
- Calculate % of calls answered within 60 sec over the full time period.
- Calculate % of calls answered within 60 sec over the full time period by area. Sort descending by

===========================================
```{r}
sitrep_full <- sitrep_full %>% 
  select(-contains('year'), -contains('day_month')) 

sitrep_full %>% 
  mutate(calls_60_p=calls_60sec/calls_all*100)

sitrep_full %>% 
  group_by(NHS_111_area_name) %>% 
  summarise(calls_60_p=sum(calls_60sec, na.rm=TRUE)/sum(calls_all, na.rm=TRUE)*100) %>% 
  arrange(desc(calls_60_p))

```




